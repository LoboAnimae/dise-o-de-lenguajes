/*! For license information please see index.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./src/Controllers/Automaton.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DFA = exports.NFA = exports.Language = exports.Or = exports.Question = exports.Positive = exports.Character = exports.Kleene = exports.Operator = void 0;\nconst Console_1 = __webpack_require__(/*! ./Console */ \"./src/Controllers/Console.ts\");\nconst Constants_1 = __webpack_require__(/*! ./Constants */ \"./src/Controllers/Constants.ts\");\nconst Tree_1 = __webpack_require__(/*! ./Tree */ \"./src/Controllers/Tree.ts\");\nconst GraphNode_1 = __webpack_require__(/*! ./GraphNode */ \"./src/Controllers/GraphNode.ts\");\nconst Structures_1 = __webpack_require__(/*! ./Structures */ \"./src/Controllers/Structures.ts\");\nclass Operator {\n    constructor(content, regex, position) {\n        this.content = content;\n        this.regex = regex;\n        this.position = position;\n        this.err = '';\n        this.position = position;\n        this.regex = regex;\n        this.content = content;\n    }\n    static getOperator(content, regex, position) {\n        if (content === Constants_1.POSITIVE) {\n            return new Positive(content, regex, position);\n        }\n        else if (content === Constants_1.KLEENE) {\n            return new Kleene(content, regex, position);\n        }\n        else if (content === Constants_1.QUESTION) {\n            return new Question(content, regex, position);\n        }\n        else if (content === Constants_1.OR) {\n            return new Or(content, regex, position);\n        }\n        else {\n            return new Character(content, regex, position);\n        }\n    }\n    static isValidTarget(target) {\n        return target !== ' '\n            && target !== Constants_1.POSITIVE\n            && target !== Constants_1.KLEENE\n            && target !== Constants_1.QUESTION\n            && target !== Constants_1.OR\n            && target !== Constants_1.OPENING_PARENTHESIS;\n    }\n    validate() {\n        if (this.position == 0) {\n            this.err = `[NO TARGET] The operator \"${this.content}\" cannot be the first character of the regex`;\n            return false;\n        }\n        const previousChar = this.regex.charAt(this.position - 1);\n        if (!Operator.isValidTarget(previousChar)) {\n            this.err = `[INVALID TARGET] The operator \"${this.content}\" can't come after the operator \"${previousChar}\".`;\n            return false;\n        }\n        return true;\n    }\n    ;\n}\nexports.Operator = Operator;\nclass Kleene extends Operator {\n}\nexports.Kleene = Kleene;\nclass Character extends Operator {\n    validate() {\n        return true;\n    }\n}\nexports.Character = Character;\nclass Positive extends Operator {\n}\nexports.Positive = Positive;\nclass Question extends Operator {\n}\nexports.Question = Question;\nclass Or extends Operator {\n    constructor() {\n        super(...arguments);\n        this.validate = () => {\n            if (this.position == 0 || this.position == this.regex.length - 1) {\n                this.err = `[NO TARGET] The operator \"|\" cannot be the first or the last character of the regex`;\n                return false;\n            }\n            const previousChar = this.regex.at(this.position - 1);\n            const nextChar = this.regex.at(this.position + 1);\n            let isValid = true;\n            if (!Operator.isValidTarget(previousChar)) {\n                this.err = `[NO TARGET] The operator \"|\" has no valid left target`;\n                isValid = false;\n            }\n            if (!Operator.isValidTarget(nextChar)) {\n                if (this.err.length !== 0) {\n                    this.err += ' nor a valid right target';\n                }\n                else {\n                    this.err = `[NO TARGET] The operator \"|\" has no valid right target`;\n                }\n                isValid = false;\n            }\n            return isValid;\n        };\n    }\n}\nexports.Or = Or;\nclass Language {\n    static isOperator(character) {\n        return Constants_1.OPERATOR_ARRAY.includes(character);\n    }\n    static getLanguage(regex) {\n        return [...new Set(regex.split(''))].filter((character) => !(Language.isOperator(character) || Constants_1.PARENTHESIS_ARRAY.includes(character)));\n        // for (const char of regex) {\n        //     if (!(foundLanguage.includes(char) || Language.isOperator(char) || PARENTHESIS_ARRAY.includes(char))) {\n        //         foundLanguage.push(char);\n        //     }\n        // }\n        // return foundLanguage;\n    }\n    static validateRegex(regex) {\n        const errors = [];\n        for (let i = 0; i < regex.length; ++i) {\n            const currentChar = regex[i];\n            const operatorInstance = Operator.getOperator(currentChar, regex, i);\n            if (!operatorInstance.validate()) {\n                const mainMessage = `[SYNTAX ERROR] Invalid Syntax in position ${i + 1}.\\n`;\n                const subMessage = `${operatorInstance.err}: `;\n                const messageDisplacement = subMessage.length;\n                const regexMessage = regex.substring(0, i) + Console_1.Console.getWithColor(Console_1.Colors.RED, currentChar) + regex.substring(i + 1) + '\\n';\n                const messageDisplacer = ' '.repeat(messageDisplacement + i);\n                errors.push(mainMessage + subMessage + regexMessage + messageDisplacer + '^ Error found here!');\n            }\n        }\n        if (errors.length) {\n            for (const error of errors) {\n                console.log(error);\n            }\n            return false;\n        }\n        return true;\n    }\n    static groupingValidation(regex) {\n        const parenthesisStack = [];\n        for (let position = 0; position < regex.length; ++position) {\n            const character = regex[position];\n            if (character === Constants_1.OPENING_PARENTHESIS) {\n                parenthesisStack.push({ character, position });\n            }\n            else if (character === Constants_1.CLOSING_PARENTHESIS) {\n                if (!parenthesisStack.length) {\n                    parenthesisStack.push({ character, position });\n                }\n                else {\n                    const popped = parenthesisStack.pop();\n                    if ((popped === null || popped === void 0 ? void 0 : popped.character) == Constants_1.CLOSING_PARENTHESIS) {\n                        parenthesisStack.push(popped);\n                        parenthesisStack.push({ character, position });\n                    }\n                    else {\n                    }\n                }\n            }\n        }\n        if (parenthesisStack.length) {\n            const regexVector = regex.split('');\n            const inverted = [];\n            while (true) {\n                const element = parenthesisStack.pop();\n                if (!element)\n                    break;\n                inverted.push(element);\n            }\n            while (inverted.length) {\n                const { character, position } = inverted.pop();\n                regexVector[position] = Console_1.Console.getWithColor(Console_1.Colors.RED, regexVector[position]);\n                const message = `[UNGROUPED SYMBOL] For operand in regex \"${regex}\": `;\n                const subMessage = regex.substring(0, position) + Console_1.Console.getWithColor(Console_1.Colors.RED, character) + regex.substring(position + 1);\n                const messagePointer = ' '.repeat(message.length + position) + '^ Missing operand';\n                console.log(message + subMessage + '\\n' + messagePointer);\n            }\n            return false;\n        }\n        return true;\n    }\n    static augmentSpecial(regex) {\n        if (!regex.length) {\n            return '';\n        }\n        if (regex.length === 1) {\n            return regex + '#';\n        }\n        let augmentedRegex = '';\n        for (let i = 0; i < regex.length; ++i) {\n            const currentChar = regex[i];\n            const nextChar = i + 1 < regex.length ? regex[i + 1] : ' ';\n            const currentCharIsBiOperator = currentChar == '(' || currentChar == '|';\n            const nextCharIgnoresConcatenation = nextChar == '|' || nextChar == '*' || nextChar == '+' || nextChar == '?' || nextChar == ')';\n            if (!(currentCharIsBiOperator || nextCharIgnoresConcatenation)) {\n                augmentedRegex += currentChar;\n                if (i + 1 < regex.length) {\n                    augmentedRegex += '.';\n                }\n            }\n            else {\n                augmentedRegex += currentChar;\n            }\n        }\n        return augmentedRegex + '.#';\n    }\n    /**\n     * Ensure that the last element is a parenthesis\n     * @param regex\n     */\n    static getSubgroupInverted(regex) {\n        const length = regex.length - 1;\n        if (regex[length] !== Constants_1.CLOSING_PARENTHESIS)\n            return { leftPosition: 0, rightPosition: length };\n        const parenthesisStack = [];\n        for (let i = length; i > 0; --i) {\n            if (regex[i] === Constants_1.CLOSING_PARENTHESIS) {\n                parenthesisStack.push(i);\n            }\n            else if (regex[i] === Constants_1.OPENING_PARENTHESIS) {\n                const lastParenthesis = parenthesisStack.pop();\n                if (!parenthesisStack.length) {\n                    return { leftPosition: i, rightPosition: length + 1 };\n                }\n            }\n        }\n        return { leftPosition: 0, rightPosition: length };\n    }\n    static replaceSpecial(regex) {\n        if (!(regex.includes(Constants_1.POSITIVE) || regex.includes(Constants_1.QUESTION))) {\n            return regex;\n        }\n        let finalRegex = '';\n        for (let i = 0; i < regex.length; ++i) {\n            const currentChar = regex[i];\n            if (![Constants_1.POSITIVE, Constants_1.QUESTION].includes(currentChar)) {\n                finalRegex += currentChar;\n                continue;\n            }\n            const { leftPosition, rightPosition } = Language.getSubgroupInverted(regex.substring(0, i));\n            finalRegex = finalRegex.substring(0, leftPosition);\n            if (currentChar === Constants_1.POSITIVE) {\n                finalRegex += regex.substring(leftPosition, rightPosition + 1) || regex.charAt(leftPosition);\n                finalRegex += (regex.substring(leftPosition, rightPosition + 1) || regex.charAt(leftPosition)) + '*';\n            }\n            else if (currentChar === Constants_1.QUESTION) {\n                finalRegex += `(${Constants_1.NULL_STATE}|${regex.substring(leftPosition, rightPosition + 1) || regex.charAt(leftPosition)})`;\n            }\n        }\n        return finalRegex;\n    }\n    static augment(regex) {\n        const specialExpanded = Language.replaceSpecial(regex);\n        const final = Language.augmentSpecial(specialExpanded);\n        // Clean extra dots\n        let lastWasConcatenation = false;\n        const finalArr = [];\n        for (const letter of final.split('')) {\n            if (letter === '.') {\n                if (lastWasConcatenation)\n                    continue;\n            }\n            finalArr.push(letter);\n        }\n        return finalArr.join('');\n    }\n}\nexports.Language = Language;\nclass NFA {\n    static from(root, counter = { counter: 1 }) {\n        if (!root) {\n            return null;\n        }\n        const value = root.getValue();\n        if (Language.isOperator(value)) {\n            switch (value) {\n                case Constants_1.CONCATENATION: {\n                    /*\n                             If it is a concatenation, just get the left and the right trees and concatenate them.\n                             In any case, a concatenation will always have left and right children to concatenate.\n                             Concatenation:\n                              Given:\n                               A.B where A is a graph for a and B is a graph for b\n\n                              Then:\n                                             a\n                                         o ----\x3e o\n                                             A                         a        b\n                                             .             =        o ----\x3e o ----\x3e o\n                                             B\n                                             b\n                                         o ----\x3e\n                             */\n                    const left = NFA.from(root.getLeft(), counter);\n                    const right = NFA.from(root.getRight(), counter);\n                    right.beginning.getTransitions().forEach((transition) => left.end.addTransition({ transition }));\n                    right.beginning = left.end;\n                    return { beginning: left.beginning, end: right.end };\n                }\n                case Constants_1.OR: {\n                    /*\n                                    An or operator will always have left and right children to work on. Even if it is a null state.\n                                    Because of this, anything beforehand must ensure that the | operator has a left and right child.\n\n                                    Given:\n                                        A | B where A is a graph for a and B is a graph for b\n\n                                    Then:\n                                                 A\n                                                 a\n                                          e  o ----\x3e o\n                                           /          \\ e  e\n                                    ----\x3e o      |     o ----\x3e\n                                          \\          / e\n                                         e  o ----\x3e o\n                                                b\n                                                B\n                                    */\n                    const beginning = new GraphNode_1.GraphNode({ counter });\n                    const left = NFA.from(root.getLeft(), counter);\n                    const right = NFA.from(root.getRight(), counter);\n                    const end = new GraphNode_1.GraphNode({ counter });\n                    beginning.addEmptyTransition(left.beginning);\n                    beginning.addEmptyTransition(right.beginning);\n                    left.end.addEmptyTransition(end);\n                    right.end.addEmptyTransition(end);\n                    return { beginning, end };\n                }\n                case Constants_1.KLEENE: {\n                    /*\n                    A kleene operator will always have a left child to work on. It does not have a right child.\n\n                    Given:\n                        A* where A is a graph for a\n\n                    Then:           <-e\n                                    -----\n                              e    /  a  \\    e\n                    ----\x3e o ----\x3e o ----\x3e o ----\x3e o ----\x3e\n                          \\                      /\n                           ----------------------\n                                     e->\n                    */\n                    if (!root.getLeft() || root.getRight()) {\n                        throw new Error('There seems to be a problem with the Kleene operator');\n                    }\n                    const beginning = new GraphNode_1.GraphNode({ counter });\n                    const middle = NFA.from(root.getLeft(), counter);\n                    const end = new GraphNode_1.GraphNode({ counter });\n                    beginning.addEmptyTransition(end);\n                    beginning.addEmptyTransition(middle.beginning);\n                    middle.end.addEmptyTransition(end);\n                    middle.end.addEmptyTransition(middle.beginning);\n                    return { beginning, end };\n                }\n                case Constants_1.POSITIVE: {\n                    /*\n                    A positive operator will always have a left child to work on. It does not have a right child.\n                    It is like a kleene operator, but it needs to appear at least once, so it's like a concatenation and a kleene operator.\n\n                    Given:\n                        A* where A is a graph for a\n\n                    Then:              <-e\n                                      -----\n                        a            /  a  \\\n                    o ----\x3e o ----\x3e o ----\x3e o ----\x3e o ----\x3e\n                             \\                      /\n                              ----------------------\n                                        e->\n                    */\n                    if (!root.getLeft() || root.getRight()) {\n                        throw new Error('There seems to be a problem with the positive operator.');\n                    }\n                    const middleForced = NFA.from(root.getLeft(), counter);\n                    const middleOptional = NFA.from(root.getLeft(), counter);\n                    const kleeneEnd = new GraphNode_1.GraphNode({ counter });\n                    middleForced.end.addEmptyTransition(middleOptional.beginning);\n                    middleOptional.end.addEmptyTransition(middleOptional.beginning);\n                    middleOptional.end.addEmptyTransition(kleeneEnd);\n                    middleForced.end.addEmptyTransition(kleeneEnd);\n                    return { beginning: middleForced.beginning, end: kleeneEnd };\n                }\n                case Constants_1.QUESTION: {\n                    /*\n                     Like the kleene operator, but it does not repeat \"as many times as possible\". Rather, it is like a \"can come or not\"\n\n                     Given:\n                         A* where A is a graph for a\n\n                     Then:\n\n                               a\n                     ----\x3e o ----\x3e o ----\x3e\n                           \\       /\n                            -------\n                               e->\n                 */\n                    const middle = NFA.from(root.getLeft(), counter);\n                    middle.beginning.addEmptyTransition(middle.end);\n                    return { beginning: middle.beginning, end: middle.end };\n                }\n                default: {\n                    throw new Error('Unimplemented operator.');\n                }\n            }\n        }\n        else {\n            /*\n\n                              a\n                            o ----\x3e o\n\n            */\n            const beginning = new GraphNode_1.GraphNode({ counter });\n            const end = new GraphNode_1.GraphNode({ counter });\n            beginning.addTransition({ to: end, using: value });\n            if (value === '#') {\n                end.setAcceptance(true);\n            }\n            return { beginning, end };\n        }\n    }\n}\nexports.NFA = NFA;\nclass DFA {\n    constructor(dfa, regex) {\n        this.dfa = dfa;\n        this.regex = regex;\n    }\n    match(toMatch) {\n        let current = this.dfa[0]; // Grab the initial state\n        for (const letter of toMatch) {\n            const found = current.getTransitions().filter((transition) => transition.using === letter);\n            if (!found.length) {\n                return false;\n            }\n            current = found[0].to;\n        }\n        return current.isAcceptance();\n    }\n    static getAcceptanceStates(nextPosTable) {\n        return nextPosTable.filter((row) => row.content === '#');\n    }\n    static directly(transitionTable, followPosTable) {\n        // Create as many nodes as there are transitions and hold them inside a vector\n        const acceptanceStates = DFA.getAcceptanceStates(followPosTable).map(row => row.state);\n        const dfaStates = transitionTable.map(row => {\n            const id = row.state.substring(1);\n            return new GraphNode_1.GraphNode({\n                id: parseInt(id),\n                acceptance: JSON.parse(row.positions).some((element) => acceptanceStates.includes(element)),\n            });\n        });\n        // For each node\n        for (const node of dfaStates) {\n            // Grab the equivalent\n            const equivalent = transitionTable.find((row) => row.state === `S${node.getId()}`);\n            // For each transition in the equivalent\n            for (const transition of equivalent.transitions) {\n                const { goesTo, using } = transition;\n                const nodeId = goesTo.substring(1);\n                // Find the equivalent\n                const transitionEquivalentNode = dfaStates.find(node => node.getId() === parseInt(nodeId));\n                // Create the transition\n                node.addTransition({ to: transitionEquivalentNode, using });\n            }\n        }\n        return dfaStates;\n    }\n    static fillNextPositionContent(root, insideTable) {\n        if (!root || !insideTable) {\n            return;\n        }\n        DFA.fillNextPositionContent(root.getLeft(), insideTable);\n        DFA.fillNextPositionContent(root.getRight(), insideTable);\n        const currentChar = root.getValue();\n        if ([Constants_1.KLEENE, Constants_1.CONCATENATION].includes(currentChar) || Language.isOperator(currentChar)) {\n            return;\n        }\n        const found = insideTable.find((row) => row.state === root.getTreeBuilderId());\n        if (found)\n            found.content = currentChar;\n        else {\n            // If not found, create a new row with it\n            insideTable.push({\n                positions: new Set(),\n                state: root.getTreeBuilderId(),\n                content: currentChar,\n            });\n        }\n    }\n    static followPos(position, transLetter, followPosTable) {\n        // Filter the positions\n        return followPosTable\n            // Grab every position in the table that is in the positions vector\n            .filter((row) => position.includes(row.state))\n            // Grab every position from the previous query that has a transition with the alphabet letter\n            .filter((row) => row.content === transLetter);\n    }\n    static from(followPosTable, initialState, alphabet) {\n        let counter = 0;\n        // The first row is composed of the firstPos of the first element\n        const transitionsTable = [{\n                positions: JSON.stringify([...new Set(initialState)].sort((a, b) => a - b)),\n                state: `S${counter++}`,\n                transitions: [],\n            }];\n        for (const row of transitionsTable) {\n            for (const alphabetMember of alphabet) {\n                const foundRows = DFA.followPos(JSON.parse(row.positions), alphabetMember, followPosTable);\n                const merged = [...new Set(foundRows.flatMap(row => [...row.positions]))];\n                merged.sort((a, b) => a - b);\n                const toCompare = JSON.stringify(merged);\n                const existing = transitionsTable.find(row => row.positions === toCompare);\n                // If it exists, add the transition to the row\n                if (existing) {\n                    row.transitions.push({\n                        goesTo: existing.state,\n                        using: alphabetMember,\n                    });\n                }\n                else {\n                    // Otherwise, create a new state, add it to the table and make the transition\n                    const newLength = transitionsTable.push({\n                        positions: toCompare,\n                        state: `S${counter++}`,\n                        transitions: [],\n                    });\n                    const table = transitionsTable.at(newLength - 1);\n                    row.transitions.push({\n                        goesTo: table.state,\n                        using: alphabetMember,\n                    });\n                }\n            }\n        }\n        return transitionsTable;\n    }\n    static generateNextPositionTable(root) {\n        const nextPositionsTables = [];\n        if (!root) {\n            return null;\n        }\n        const currentOperator = root.getValue();\n        const resultLeft = DFA.generateNextPositionTable(root.getLeft());\n        const resultRight = DFA.generateNextPositionTable(root.getRight());\n        nextPositionsTables.push(...(resultLeft !== null && resultLeft !== void 0 ? resultLeft : []));\n        nextPositionsTables.push(...(resultRight !== null && resultRight !== void 0 ? resultRight : []));\n        if (currentOperator === Constants_1.CONCATENATION) {\n            for (const lastPosElement of root.getLeft().getLastPosition()) {\n                for (const firstPosElement of root.getRight().getFirstPosition()) {\n                    const found = nextPositionsTables.find((row) => row.state === lastPosElement);\n                    if (found) {\n                        found.positions.add(firstPosElement);\n                    }\n                    else {\n                        const newRow = {\n                            positions: new Set([firstPosElement]),\n                            state: lastPosElement,\n                            content: '',\n                        };\n                        nextPositionsTables.push(newRow);\n                    }\n                }\n            }\n        }\n        else if (currentOperator === Constants_1.KLEENE) {\n            root.getLastPosition().forEach(lastPosElement => {\n                root.getFirstPosition().forEach(firstPosElement => {\n                    const found = nextPositionsTables.find((row) => row.state === lastPosElement);\n                    if (found) {\n                        found.positions.add(firstPosElement);\n                    }\n                    else {\n                        const newRow = {\n                            positions: new Set([firstPosElement]),\n                            state: lastPosElement,\n                            content: '',\n                        };\n                        nextPositionsTables.push(newRow);\n                    }\n                });\n            });\n        }\n        return nextPositionsTables;\n    }\n    static generate(regex, ignoreAugment) {\n        const alphabet = Language.getLanguage(regex);\n        const augmented = ignoreAugment ? regex : regex.length === 1 ? `${regex}.#` : Language.augment(regex);\n        const syntaxTree = Tree_1.TreeNode.from(augmented);\n        const saveIn = [];\n        Structures_1.JSONProj.from(syntaxTree, saveIn);\n        // fs.writeFile(regex + '_syntaxTree.json', JSON.stringify(saveIn), () => {\n        // });\n        // const nfa = NFA.from(syntaxTree);\n        const next = DFA.generateNextPositionTable(syntaxTree);\n        next.sort((a, b) => a.state - b.state);\n        next.push({ positions: new Set(), state: next[next.length - 1].state + 1, content: '' });\n        DFA.fillNextPositionContent(syntaxTree, next);\n        next.sort((a, b) => a.state - b.state);\n        const transitionsTable = DFA.from(next, syntaxTree.getFirstPosition(), alphabet);\n        // fs.writeFile(regex + '_DFA.json', JSON.stringify(transitionsTable), () => {\n        // });\n        return new DFA(DFA.directly(transitionsTable, next), regex);\n    }\n}\nexports.DFA = DFA;\nexports[\"default\"] = { Language, Operator, NFA, DFA };\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/Automaton.ts?")},"./src/Controllers/CCompiler.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CompilerHelper_isKeyword, _CompilerHelper_isCompiler, _CompilerHelper_isCharacterIdentifier, _CompilerHelper_isCharacter, _CompilerHelper_isToken, _CompilerHelper_getIdentifier;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.COMPILER_KEYWORDS = exports.CompilerHelper = exports.SPACE_REPLACEMENT = exports.DOT_REPLACEMENT = exports.END = exports.TOKENS = exports.KEYWORDS = exports.CHARACTERS = exports.COMPILER = void 0;\nconst Automaton_1 = __webpack_require__(/*! ./Automaton */ \"./src/Controllers/Automaton.ts\");\nconst Constants_1 = __webpack_require__(/*! ./Constants */ \"./src/Controllers/Constants.ts\");\nexports.COMPILER = 'COMPILER';\nexports.CHARACTERS = 'CHARACTERS';\nexports.KEYWORDS = 'KEYWORDS';\nexports.TOKENS = 'TOKENS';\nexports.END = 'END';\nexports.DOT_REPLACEMENT = '\\u8889';\nexports.SPACE_REPLACEMENT = '\\u8888';\nclass CompilerHelper {\n    constructor(params) {\n        var _a, _b, _c, _d, _e;\n        this.COMPILER = undefined;\n        this.CHARACTERS = undefined;\n        this.KEYWORDS = undefined;\n        this.TOKENS = undefined;\n        this.END = undefined;\n        this.tagContents = {};\n        /**\n         * Gets the content from a compiler. Please ensure that the first word of the content parameter is the same as the compiler's instance COMPILER word\n         * @param content The content to be gotten.\n         * @returns An object with the content of the different tags\n         */\n        this.getAllTagContent = (content) => {\n            if (Object.keys(this.tagContents).length)\n                return this.tagContents;\n            if (!content) {\n                return null;\n            }\n            const returnObj = {};\n            const compilerRegex = this.getCompiler().regex;\n            const charactersRegex = this.getCharacters().regex;\n            const keywordsRegex = this.getKeywords().regex;\n            const tokensRegex = this.getTokens().regex;\n            // Gets everything from the compiler\n            returnObj[compilerRegex] = this.getCompilerContent(content.join('\\n'));\n            // @ts-ignore\n            returnObj[charactersRegex] = { tags: this.getContent(returnObj[this.getCompiler().regex], this.getCharacters()) };\n            returnObj[keywordsRegex] = this.getContent(content.join('\\n'), this.getKeywords());\n            returnObj[keywordsRegex] = Object.keys(returnObj[keywordsRegex]).map((tag) => {\n                return {\n                    tag,\n                    content: returnObj[keywordsRegex][tag].replaceAll('\"', ''),\n                    matcher: undefined,\n                };\n            });\n            const tokenRaw = this.getContent(content.join('\\n'), this.getTokens());\n            returnObj[tokensRegex] = {};\n            Object.keys(tokenRaw).forEach((tag) => returnObj[tokensRegex][tag] = { content: tokenRaw[tag] });\n            Object.keys(returnObj[charactersRegex].tags).forEach((tag) => {\n                let finalStr = '';\n                let cache = '';\n                for (const word of returnObj[charactersRegex].tags[tag].split('+').map((str) => str.trim())) {\n                    if (word.charAt(0) === '\"') {\n                        finalStr += word.replaceAll('\"', '');\n                    }\n                    else if (word.includes('CHR(')) {\n                        const startingIndex = returnObj[charactersRegex].tags[tag].indexOf('CHR(');\n                        const endingIndex = returnObj[charactersRegex].tags[tag].substring(startingIndex).indexOf(')');\n                        const charNumber = parseInt(word.substring(startingIndex + 'CHR('.length, endingIndex + 1));\n                        const charToAdd = String.fromCharCode(charNumber);\n                        finalStr += charToAdd;\n                    }\n                    else\n                        finalStr += returnObj[charactersRegex].tags[word].join('');\n                }\n                // @ts-ignore\n                returnObj[charactersRegex].tags[tag] = finalStr.split('');\n            });\n            // Generate a language DFA for this\n            returnObj[charactersRegex].matcher = [];\n            Object.keys(returnObj[charactersRegex].tags).forEach((tag) => {\n                const language = returnObj[charactersRegex].tags[tag];\n                let finalStr = language.at(0);\n                for (const letter of language) {\n                    if (letter === finalStr)\n                        continue;\n                    finalStr = letter + `|(${finalStr})`;\n                }\n                const dfa = Automaton_1.DFA.generate(`(${finalStr})+`);\n                returnObj[charactersRegex].matcher.push({\n                    identifier: tag,\n                    identifierDFA: Automaton_1.DFA.generate(tag),\n                    values: returnObj[charactersRegex].tags[tag],\n                    dfa,\n                });\n            });\n            delete returnObj[charactersRegex].tags;\n            Object.keys(returnObj[tokensRegex]).forEach((tag) => {\n                if (returnObj[tokensRegex][tag].content.includes('EXCEPT')) {\n                    const exceptLength = 'EXCEPT'.length;\n                    const exceptPosition = returnObj[tokensRegex][tag].content.indexOf('EXCEPT');\n                    const str = returnObj[tokensRegex][tag].content;\n                    const contentPart = str.substring(0, exceptPosition).trim();\n                    const exceptPart = str.substring(exceptLength + exceptPosition).trim();\n                    returnObj[tokensRegex][tag].content = contentPart;\n                    returnObj[tokensRegex][tag].exceptions = exceptPart.split(' ');\n                }\n                else {\n                    returnObj[tokensRegex][tag].exceptions = [];\n                }\n                returnObj[tokensRegex][tag].content = returnObj[tokensRegex][tag].content.replaceAll('{', Constants_1.OPENING_PARENTHESIS);\n                returnObj[tokensRegex][tag].content = returnObj[tokensRegex][tag].content.replaceAll('}', Constants_1.CLOSING_PARENTHESIS + '*');\n                returnObj[tokensRegex][tag].content = returnObj[tokensRegex][tag].content.replaceAll('\"', '');\n                returnObj[tokensRegex][tag].content = returnObj[tokensRegex][tag].content.replaceAll('.', exports.DOT_REPLACEMENT);\n            });\n            returnObj[tokensRegex] = Object.keys(returnObj[tokensRegex]).map((tag) => ({\n                tag,\n                content: returnObj[tokensRegex][tag].content,\n                exceptions: returnObj[tokensRegex][tag].exceptions,\n                matcher: undefined,\n            }));\n            for (const token of returnObj[tokensRegex]) {\n                // Make it so that all the space between contents\n                let tokenContent = token.content;\n                tokenContent = tokenContent.replaceAll(' ', exports.SPACE_REPLACEMENT);\n                returnObj[charactersRegex].matcher.sort((a, b) => b.identifier.length - a.identifier.length);\n                for (const char of returnObj[charactersRegex].matcher) {\n                    tokenContent = tokenContent.replaceAll(char.identifier, `(${CompilerHelper.getAllProbabilities(char.values.join(''))})`);\n                }\n                tokenContent = tokenContent.replaceAll(exports.SPACE_REPLACEMENT, '');\n                token.matcher = Automaton_1.DFA.generate(tokenContent);\n                // token.matcher = DFA.generate(output.map((outputMapper) => {\n                //     const augmented = Language.augment(outputMapper);\n                //     return augmented.substring(0, augmented.length - 2);\n                // }).join('.') + '.#', true);\n            }\n            this.tagContents = returnObj;\n            return this.tagContents;\n        };\n        this.getCompilerContent = (content) => {\n            // Identify that the compiler has a beginning and end tag\n            const compilerTag = content.indexOf(this.getCompiler().regex);\n            // The word directly next to the compiler is the compiler name\n            const compilerName = content.substring(compilerTag).split(' ')[1].split('\\n')[0];\n            const expectedTag = `${this.getCompiler().regex} ${compilerName}`;\n            const end = content.lastIndexOf(`${this.getEnd().regex} ${compilerName}`);\n            let resulting = content.substring(expectedTag.length, end).trim();\n            if (resulting.at(0) === '\\n')\n                resulting = resulting.substring(1);\n            if (resulting.at(resulting.length - 1) === '\\n')\n                resulting = resulting.substring(0, resulting.length - 2);\n            return resulting.trim();\n        };\n        this.getContent = (content, using) => {\n            const returnObj = {};\n            // Advance to the part where the character word is the character tag\n            let rawContent = '';\n            let saveContent = false;\n            //@ts-ignore\n            for (const word of content.replaceAll('\\n', ' ').split(' ')) {\n                if (!saveContent && using.match(word)) {\n                    saveContent = true;\n                    continue;\n                }\n                else if (saveContent && this.isTag(word)) {\n                    break;\n                }\n                if (saveContent) {\n                    rawContent += ' ' + word;\n                }\n            }\n            rawContent = rawContent.trim();\n            const words = rawContent.split(' ');\n            // The raw content was obtained. Parse it into several tags.\n            for (let i = 0; i < words.length; ++i) {\n                if (i === 0)\n                    continue;\n                if (words[i] === '=') {\n                    // Grab the previous word\n                    const previousWord = words[i - 1];\n                    let insideContent = '';\n                    while (true) {\n                        const currentWord = words[++i];\n                        if (currentWord === '.')\n                            break;\n                        else if (currentWord.includes('.')) {\n                            const until = currentWord.lastIndexOf('.');\n                            insideContent += ' ' + currentWord.substring(0, until);\n                            break;\n                        }\n                        else\n                            insideContent += ' ' + currentWord;\n                    }\n                    insideContent = insideContent.trim();\n                    returnObj[previousWord] = insideContent;\n                }\n            }\n            return returnObj;\n        };\n        this.isTag = (word) => {\n            return this.getAll().some((dfa) => dfa.match(word));\n        };\n        this.toString = () => {\n            console.log(this);\n            const charactersRegex = this.getCharacters().regex;\n            const keywordsRegex = this.getKeywords().regex;\n            const tokensRegex = this.getTokens().regex;\n            const CHARACTERS = [];\n            const KEYWORDS = [];\n            const TOKENS = [];\n            for (const character of this.tagContents[charactersRegex].matcher) {\n                const { identifier, dfa, exceptions } = character;\n                const dfaObject = dfa.dfa.map((currentDFA) => ({\n                    isAcceptance: currentDFA.isAcceptance(),\n                    id: currentDFA.getId(),\n                    transitions: currentDFA.getTransitions().map(transition => ({\n                        using: transition.using,\n                        to: transition.to.getId(),\n                    })),\n                }));\n                CHARACTERS.push({ identifier, dfa: dfaObject, exceptions: exceptions !== null && exceptions !== void 0 ? exceptions : [] });\n            }\n            for (const keyword of this.tagContents[keywordsRegex]) {\n                if (!keyword.matcher) {\n                    // this.tagContents[keywordsRegex].find([keyword] = DFA.generate(keyword.tag);\n                    keyword.matcher = Automaton_1.DFA.generate(keyword.tag);\n                }\n                const { tag: identifier, matcher, exceptions } = keyword;\n                const dfaObject = matcher.dfa.map((currentDFA) => ({\n                    isAcceptance: currentDFA.isAcceptance(),\n                    id: currentDFA.getId(),\n                    transitions: currentDFA.getTransitions().map(transition => ({\n                        using: transition.using,\n                        to: transition.to.getId(),\n                    })),\n                }));\n                KEYWORDS.push({ identifier, dfa: dfaObject, exceptions: exceptions !== null && exceptions !== void 0 ? exceptions : [] });\n            }\n            for (const token of this.tagContents[tokensRegex]) {\n                if (!token.matcher) {\n                    // this.tagContents[keywordsRegex].find([token] = DFA.generate(token.tag);\n                    token.matcher = Automaton_1.DFA.generate(token.tag);\n                }\n                const { tag: identifier, matcher, exceptions } = token;\n                const dfaObject = matcher.dfa.map((currentDFA) => ({\n                    isAcceptance: currentDFA.isAcceptance(),\n                    id: currentDFA.getId(),\n                    transitions: currentDFA.getTransitions().map(transition => ({\n                        using: transition.using,\n                        to: transition.to.getId(),\n                    })),\n                }));\n                TOKENS.push({ identifier, dfa: dfaObject, exceptions: exceptions !== null && exceptions !== void 0 ? exceptions : [] });\n            }\n            return JSON.stringify({ CHARACTERS, KEYWORDS, TOKENS });\n        };\n        this.getCompiler = () => {\n            if (this.COMPILER)\n                return this.COMPILER;\n            this.COMPILER = Automaton_1.DFA.generate(this.KEYWORDS_ARRAY[0] || exports.COMPILER);\n            return this.COMPILER;\n        };\n        this.getCharacters = () => {\n            if (this.CHARACTERS)\n                return this.CHARACTERS;\n            this.CHARACTERS = Automaton_1.DFA.generate(this.KEYWORDS_ARRAY[1] || exports.CHARACTERS);\n            return this.CHARACTERS;\n        };\n        this.getKeywords = () => {\n            if (this.KEYWORDS)\n                return this.KEYWORDS;\n            this.KEYWORDS = Automaton_1.DFA.generate(this.KEYWORDS_ARRAY[2] || exports.KEYWORDS);\n            return this.KEYWORDS;\n        };\n        this.getTokens = () => {\n            if (this.TOKENS)\n                return this.TOKENS;\n            this.TOKENS = Automaton_1.DFA.generate(this.KEYWORDS_ARRAY[3] || exports.TOKENS);\n            return this.TOKENS;\n        };\n        this.getEnd = () => {\n            if (this.END)\n                return this.END;\n            this.END = Automaton_1.DFA.generate(this.KEYWORDS_ARRAY[4] || exports.END);\n            return this.END;\n        };\n        this.getAll = () => {\n            return [this.getCompiler(), this.getCharacters(), this.getKeywords(), this.getTokens(), this.getEnd()];\n        };\n        _CompilerHelper_isKeyword.set(this, (word) => {\n            const { KEYWORDS } = this.getAllTagContent();\n            if (!KEYWORDS)\n                return '';\n            for (const keyword of KEYWORDS) {\n                if (!keyword.matcher)\n                    keyword.matcher = Automaton_1.DFA.generate(keyword.content);\n                if (keyword.matcher.match(word))\n                    return `<${word}-keyword>`;\n            }\n            return '';\n        });\n        // #getKeywordDFA = (word: string) => {\n        //     if (!this.#isKeyword(word)) return null;\n        //     const {CHARACTERS} = this.getAllTagContent() as { CHARACTERS?: { identifier: string; identifierDFA: DFA, values: string[], dfa: DFA }[] };\n        //     if (!CHARACTERS) throw new Error('Uncaught keyword DFA discovery');\n        //     let currentWord = '';\n        //     let finalDFA: DFA[] = [];\n        //     for (const letter of word) {\n        //         currentWord += letter;\n        //         if (!this.#isCharacterIdentifier(currentWord)) {\n        //             if (!finalDFA) finalDFA = DFA.generate(currentWord);\n        //             else {\n        //                 const toAttach = DFA.generate(currentWord);\n        //                 const attachTo = finalDFA.dfa;\n        //\n        //                 // Grab the last node from the AttachTo\n        //                 const firstDFAFromToAttach: GraphNode = toAttach.dfa.at(0)!;\n        //                 const lastDFAFromAttachTo: GraphNode = attachTo.pop()!;\n        //\n        //                 // Merge the last node\n        //\n        //\n        //                 const beforeLastDFA = finalDFA.dfa[finalDFA.dfa.length - 1];\n        //\n        //                 // These transitions will remain the same, except for the one that went into the lastDFA\n        //                 // That transition will have to now point towards the new DFA\n        //                 const beforeLastDFATransition = beforeLastDFA.getTransitions();\n        //                 const lastDFATransition = lastDFA.getTransitions();\n        //\n        //\n        //             }\n        //\n        //             currentWord = '';\n        //         }\n        //\n        //     }\n        // };\n        // generateTokenDFA = (cont: string): DFA => {\n        //\n        // };\n        _CompilerHelper_isCompiler.set(this, () => {\n        });\n        _CompilerHelper_isCharacterIdentifier.set(this, (word) => {\n            for (const dfa of this.tagContents.CHARACTERS) {\n                if (dfa.identifierDFA.match(word)) {\n                    return dfa.identifierDFA;\n                }\n            }\n            return null;\n        });\n        _CompilerHelper_isCharacter.set(this, (word) => {\n            const { CHARACTERS } = this.getAllTagContent();\n            if (!CHARACTERS)\n                return '<Error-Type>';\n            for (const dfa of CHARACTERS.matcher) {\n                if (dfa.dfa.match(word)) {\n                    return dfa.identifier;\n                }\n            }\n            return '<Error-Type>';\n        });\n        _CompilerHelper_isToken.set(this, (word) => {\n            var _a;\n            const allContent = this.getAllTagContent();\n            if (!((_a = allContent.TOKENS) === null || _a === void 0 ? void 0 : _a.length))\n                return '<Error-Type>';\n            for (const token of allContent.TOKENS) {\n                if (token.matcher.match(word)) {\n                    let consider = true;\n                    for (const exception of token.exceptions) {\n                        consider = !allContent[exception].find((subException) => subException.matcher.match(word));\n                    }\n                    if (consider)\n                        // @ts-ignore\n                        return `<${word.replaceAll(exports.DOT_REPLACEMENT, '.')}-${token.tag}>`;\n                }\n            }\n            return '<Error-Type>';\n        });\n        _CompilerHelper_getIdentifier.set(this, (word) => {\n        });\n        this.KEYWORDS_ARRAY = [\n            (_a = params === null || params === void 0 ? void 0 : params.COMPILER) !== null && _a !== void 0 ? _a : exports.COMPILER,\n            (_b = params === null || params === void 0 ? void 0 : params.CHARACTERS) !== null && _b !== void 0 ? _b : exports.CHARACTERS,\n            (_c = params === null || params === void 0 ? void 0 : params.KEYWORDS) !== null && _c !== void 0 ? _c : exports.KEYWORDS,\n            (_d = params === null || params === void 0 ? void 0 : params.TOKENS) !== null && _d !== void 0 ? _d : exports.TOKENS,\n            (_e = params === null || params === void 0 ? void 0 : params.END) !== null && _e !== void 0 ? _e : exports.END,\n        ];\n        if (params === null || params === void 0 ? void 0 : params.content) {\n            for (const dfa of this.getAll()) {\n                let found = false;\n                for (const words of params.content) {\n                    for (const word of words.split(' ')) {\n                        if (dfa.match(word)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (found)\n                        break;\n                }\n                if (!found)\n                    throw new Error(`Could not find the tag ${dfa.regex}`);\n            }\n            this.getAllTagContent(params.content);\n        }\n    }\n    static getAllProbabilities(word) {\n        if (word.length === 1 || word.length === 0)\n            return word;\n        let finalStr = word.at(0);\n        for (const letter of word) {\n            if (letter === finalStr)\n                continue;\n            finalStr = letter + `|(${finalStr})`;\n        }\n        return finalStr;\n    }\n    ;\n    static sanitize(str) {\n        if (!str.includes('=')) {\n            return str;\n        }\n        const strArr = [];\n        let sanitized = '';\n        let ignoreWhitespace = false;\n        for (const letter of str.split('')) {\n            if (letter === ' ') {\n                if (!ignoreWhitespace) {\n                    ignoreWhitespace = true;\n                    strArr.push(letter);\n                }\n            }\n            else {\n                ignoreWhitespace = false;\n                strArr.push(letter);\n            }\n        }\n        return strArr.join('');\n    }\n    recognize(word) {\n        // First, check if it is a keyword (which might go outside the language)\n        if (__classPrivateFieldGet(this, _CompilerHelper_isKeyword, \"f\").call(this, word))\n            return `<${word}-Token>`;\n        // Second, assume that it is some identifier that is inside the language\n        return __classPrivateFieldGet(this, _CompilerHelper_isToken, \"f\").call(this, word);\n    }\n}\nexports.CompilerHelper = CompilerHelper;\n_CompilerHelper_isKeyword = new WeakMap(), _CompilerHelper_isCompiler = new WeakMap(), _CompilerHelper_isCharacterIdentifier = new WeakMap(), _CompilerHelper_isCharacter = new WeakMap(), _CompilerHelper_isToken = new WeakMap(), _CompilerHelper_getIdentifier = new WeakMap();\n;\nexports.COMPILER_KEYWORDS = [exports.COMPILER, exports.CHARACTERS, exports.KEYWORDS, exports.TOKENS, exports.END];\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/CCompiler.ts?")},"./src/Controllers/Console.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Console = exports.Colors = void 0;\nvar Colors;\n(function (Colors) {\n    Colors[Colors["BLACK"] = 30] = "BLACK";\n    Colors[Colors["RED"] = 31] = "RED";\n    Colors[Colors["GREEN"] = 32] = "GREEN";\n    Colors[Colors["YELLOW"] = 33] = "YELLOW";\n    Colors[Colors["BLUE"] = 34] = "BLUE";\n    Colors[Colors["MAGENTA"] = 35] = "MAGENTA";\n    Colors[Colors["CYAN"] = 36] = "CYAN";\n    Colors[Colors["WHITE"] = 37] = "WHITE";\n    Colors[Colors["RESET"] = 0] = "RESET";\n})(Colors = exports.Colors || (exports.Colors = {}));\nclass Console {\n    static getWithColor(color, message) {\n        return `\\x1b[${color}m${message}\\x1b[${Colors.RESET}m`;\n    }\n    static printWithColor(color, message) {\n        console.log(Console.getWithColor(color, message));\n    }\n}\nexports.Console = Console;\nexports["default"] = { Console, Colors };\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/Console.ts?')},"./src/Controllers/Constants.ts":(__unused_webpack_module,exports)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DUAL_OPERATORS = exports.SINGULAR_OPERATORS = exports.PARENTHESIS_ARRAY = exports.OPERATOR_ARRAY = exports.NULL_STATE = exports.CLOSING_PARENTHESIS = exports.OPENING_PARENTHESIS = exports.QUESTION = exports.POSITIVE = exports.KLEENE = exports.CONCATENATION = exports.OR = void 0;\nexports.OR = '|';\nexports.CONCATENATION = '.';\nexports.KLEENE = '*';\nexports.POSITIVE = '+';\nexports.QUESTION = '?';\nexports.OPENING_PARENTHESIS = '(';\nexports.CLOSING_PARENTHESIS = ')';\nexports.NULL_STATE = 'ε';\nexports.OPERATOR_ARRAY = [exports.OR, exports.CONCATENATION, exports.KLEENE, exports.POSITIVE, exports.QUESTION];\nexports.PARENTHESIS_ARRAY = [exports.OPENING_PARENTHESIS, exports.CLOSING_PARENTHESIS];\nexports.SINGULAR_OPERATORS = [exports.KLEENE, exports.POSITIVE, exports.QUESTION];\nexports.DUAL_OPERATORS = [exports.CONCATENATION, exports.OR];\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/Constants.ts?")},"./src/Controllers/GraphNode.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.GraphNode = void 0;\nconst Node_1 = __webpack_require__(/*! ./Node */ "./src/Controllers/Node.ts");\nconst Constants_1 = __webpack_require__(/*! ./Constants */ "./src/Controllers/Constants.ts");\nclass GraphNode extends Node_1.Node {\n    constructor(params) {\n        var _a;\n        if ((_a = params === null || params === void 0 ? void 0 : params.counter) === null || _a === void 0 ? void 0 : _a.counter) {\n            params.id = params.counter.counter++;\n        }\n        super(params);\n        this.addTransition = (newTransition) => {\n            var _a;\n            const { transition, to, using } = newTransition;\n            if (!(transition || (to && using))) {\n                throw new Error(\'Transition parameters incomplete\');\n            }\n            // @ts-ignore\n            this.transitionsTo.push((_a = newTransition.transition) !== null && _a !== void 0 ? _a : { using, to });\n        };\n        this.addEmptyTransition = (toState) => {\n            this.transitionsTo.push({ using: Constants_1.NULL_STATE, to: toState });\n        };\n        this.getTransitions = () => this.transitionsTo;\n        this.transitionsTo = [];\n    }\n}\nexports.GraphNode = GraphNode;\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/GraphNode.ts?')},"./src/Controllers/Node.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ContentNode = exports.Node = void 0;\nclass Node {\n    constructor(params) {\n        var _a, _b;\n        this.getId = () => this.stateId;\n        this.isAcceptance = () => this.isAcceptanceState;\n        this.setId = (newId) => {\n            this.stateId = newId;\n        };\n        this.setAcceptance = (newAcceptance) => {\n            this.isAcceptanceState = newAcceptance;\n        };\n        this.stateId = (_a = params === null || params === void 0 ? void 0 : params.id) !== null && _a !== void 0 ? _a : -1;\n        this.isAcceptanceState = (_b = params === null || params === void 0 ? void 0 : params.acceptance) !== null && _b !== void 0 ? _b : false;\n    }\n}\nexports.Node = Node;\n;\nclass ContentNode extends Node {\n    constructor(params) {\n        var _a;\n        super(params);\n        this.content = null;\n        this.getValue = () => this.content;\n        this.content = (_a = params === null || params === void 0 ? void 0 : params.content) !== null && _a !== void 0 ? _a : null;\n    }\n}\nexports.ContentNode = ContentNode;\nexports["default"] = { Node, ContentNode };\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/Node.ts?')},"./src/Controllers/Structures.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.JSONProj = void 0;\nconst Constants_1 = __webpack_require__(/*! ./Constants */ "./src/Controllers/Constants.ts");\nclass JSONProj {\n    static getSubgroup(regex, fromPosition) {\n        if (!(regex.includes(Constants_1.OPENING_PARENTHESIS) && regex.includes(Constants_1.CLOSING_PARENTHESIS))) {\n            return null;\n        }\n        const parenthesisStack = [];\n        for (let i = 0; i < regex.length; ++i) {\n            const currentChar = regex[i];\n            if (currentChar === Constants_1.OPENING_PARENTHESIS) {\n                parenthesisStack.push(i);\n            }\n            else if (currentChar === Constants_1.CLOSING_PARENTHESIS) {\n                const lastParenthesis = parenthesisStack.pop();\n                if (!parenthesisStack.length) {\n                    return { leftPosition: lastParenthesis + fromPosition + 1, rightPosition: i + fromPosition - 1 };\n                }\n            }\n        }\n        return null;\n    }\n    static from(root, saveIn) {\n        var _a, _b, _c, _d;\n        if (!root) {\n            return;\n        }\n        const left = (_b = (_a = root.getLeft()) === null || _a === void 0 ? void 0 : _a.getId()) !== null && _b !== void 0 ? _b : -1;\n        const right = (_d = (_c = root.getRight()) === null || _c === void 0 ? void 0 : _c.getId()) !== null && _d !== void 0 ? _d : -1;\n        saveIn.push({\n            id: root.getId(),\n            left,\n            right,\n            acceptance: root.isAcceptance(),\n            content: root.getValue(),\n        });\n        JSONProj.from(root.getLeft(), saveIn);\n        JSONProj.from(root.getRight(), saveIn);\n    }\n}\nexports.JSONProj = JSONProj;\nexports["default"] = { JSONProj };\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/Structures.ts?')},"./src/Controllers/Tree.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TreeNode = void 0;\nconst Node_1 = __webpack_require__(/*! ./Node */ \"./src/Controllers/Node.ts\");\nconst Constants_1 = __webpack_require__(/*! ./Constants */ \"./src/Controllers/Constants.ts\");\nconst Structures_1 = __webpack_require__(/*! ./Structures */ \"./src/Controllers/Structures.ts\");\nclass TreeNode extends Node_1.ContentNode {\n    constructor(params) {\n        super(params);\n        this.left = null;\n        this.right = null;\n        this.setLeft = (left) => {\n            this.left = left;\n        };\n        this.getLeft = () => this.left;\n        this.setRight = (right) => {\n            this.right = right;\n        };\n        this.getRight = () => this.right;\n        this.setNullable = (nullable) => {\n            this.isNullable = nullable;\n        };\n        this.getNullable = () => this.isNullable;\n        this.getFirstPosition = () => this.firstPosition || [];\n        this.getLastPosition = () => this.lastPosition || [];\n        this.setTreeNodeId = (newId) => {\n            this.treeBuilderId = newId;\n        };\n        this.getTreeBuilderId = () => this.treeBuilderId;\n        this.left = (params === null || params === void 0 ? void 0 : params.left) || null;\n        this.right = (params === null || params === void 0 ? void 0 : params.right) || null;\n        this.treeBuilderId = -1;\n        this.firstPosition = [];\n        this.lastPosition = [];\n        this.isNullable = false;\n    }\n    static generate(regex, counter = { counter: 1 }) {\n        if (!regex.length) {\n            return null;\n        }\n        if (regex.length === 1) {\n            return new TreeNode({ id: counter.counter++, content: regex[0] });\n        }\n        let parent = null;\n        for (let i = 0; i < regex.length; ++i) {\n            const currentChar = regex[i];\n            if (currentChar === Constants_1.CLOSING_PARENTHESIS) {\n                // Do nothing\n            }\n            else if (currentChar === Constants_1.OPENING_PARENTHESIS) {\n                const subgroupPositions = Structures_1.JSONProj.getSubgroup(regex.substring(i), i);\n                if (!subgroupPositions) {\n                    throw new Error('[BUG] Unbalanced parenthesis');\n                }\n                const { leftPosition, rightPosition } = subgroupPositions;\n                const contentInsideParenthesis = regex.substring(leftPosition, rightPosition + 1);\n                if (!contentInsideParenthesis.length) {\n                    continue;\n                }\n                const grouperNode = new TreeNode({ id: counter.counter++, content: currentChar });\n                const subtree = TreeNode.generate(contentInsideParenthesis, counter);\n                i += rightPosition - leftPosition + 1;\n                if (subtree) {\n                    grouperNode.setLeft(subtree);\n                }\n                if (!parent) {\n                    parent = grouperNode;\n                }\n                else if (!parent.getLeft()) {\n                    parent.setLeft(grouperNode);\n                }\n                else if (!parent.getRight()) {\n                    parent.setRight(grouperNode);\n                }\n                else {\n                    throw new Error('[BUG] Unbalanced parenthesis spawned more than two children for a node');\n                }\n            }\n            else if (Constants_1.SINGULAR_OPERATORS.includes(currentChar)) {\n                if (!parent) {\n                    throw new Error('[BUG] An operator has no target');\n                }\n                if (parent.getRight()) {\n                    const target = parent.getRight();\n                    const operatorNode = new TreeNode({ id: counter.counter++, content: currentChar });\n                    operatorNode.setLeft(target);\n                    parent.setRight(operatorNode);\n                }\n                else if (parent.getLeft()) {\n                    const target = parent.getLeft();\n                    const operatorNode = new TreeNode({ id: counter.counter++, content: currentChar });\n                    operatorNode.setLeft(target);\n                    parent.setLeft(operatorNode);\n                }\n                else {\n                    parent = new TreeNode({ id: counter.counter++, content: currentChar, left: parent });\n                }\n            }\n            else if (Constants_1.DUAL_OPERATORS.includes(currentChar)) {\n                if (!parent) {\n                    throw new Error('A dual operator has no target(s)!');\n                }\n                parent = new TreeNode({ id: counter.counter++, content: currentChar, left: parent });\n            }\n            else {\n                const newNode = new TreeNode({ id: counter.counter++, content: currentChar });\n                if (!parent) {\n                    parent = newNode;\n                }\n                else if (!parent.getLeft()) {\n                    parent.setLeft(newNode);\n                }\n                else if (!parent.getRight()) {\n                    parent.setRight(newNode);\n                }\n                else {\n                    throw new Error('[SYNTAX_ERROR] There seems to be a problem with the augmented expression');\n                }\n            }\n        }\n        return parent;\n    }\n    static clean(root, side, parent) {\n        if (!root) {\n            return;\n        }\n        TreeNode.clean(root.getLeft(), 'l', root);\n        TreeNode.clean(root.getRight(), 'r', root);\n        if (root.getValue() === Constants_1.OPENING_PARENTHESIS) {\n            if (!parent) {\n                throw new Error('[SYNTAX ERROR] Ungrouped symbol while cleaning the tree');\n            }\n            if (side === 'l') {\n                parent.setLeft(root.getLeft());\n            }\n            else if (side === 'r') {\n                parent.setRight(root.getLeft());\n            }\n            else {\n                throw new Error('[SYNTAX ERROR] Syntax error found while cleaning the tree');\n            }\n        }\n    }\n    static setDFAInputs(root, counter = { counter: 1 }) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;\n        if (!root) {\n            return;\n        }\n        let alreadyIncremented = false;\n        let isOperator = true;\n        TreeNode.setDFAInputs(root.getLeft(), counter);\n        TreeNode.setDFAInputs(root.getRight(), counter);\n        const currentChar = root.getValue();\n        if (currentChar === Constants_1.NULL_STATE) {\n            root.setNullable(true);\n            isOperator = false;\n        }\n        else if (currentChar === Constants_1.OR) {\n            const leftIsNullable = !!((_a = root.getLeft()) === null || _a === void 0 ? void 0 : _a.isNullable), rightIsNullable = !!((_b = root.getRight()) === null || _b === void 0 ? void 0 : _b.isNullable);\n            root.setNullable(leftIsNullable || rightIsNullable);\n            root.firstPosition = [...new Set([...(((_c = root.getLeft()) === null || _c === void 0 ? void 0 : _c.getFirstPosition()) || []), ...(((_d = root.getRight()) === null || _d === void 0 ? void 0 : _d.getFirstPosition()) || [])])];\n            root.lastPosition = [...new Set([...(((_e = root.getLeft()) === null || _e === void 0 ? void 0 : _e.getLastPosition()) || []), ...(((_f = root.getRight()) === null || _f === void 0 ? void 0 : _f.getLastPosition()) || [])])];\n        }\n        else if (currentChar === Constants_1.CONCATENATION) {\n            const leftIsNullable = !!((_g = root.getLeft()) === null || _g === void 0 ? void 0 : _g.isNullable), rightIsNullable = !!((_h = root.getRight()) === null || _h === void 0 ? void 0 : _h.isNullable);\n            root.setNullable(leftIsNullable && rightIsNullable);\n            if (leftIsNullable) {\n                root.firstPosition = [...new Set([...(_j = root.getLeft()) === null || _j === void 0 ? void 0 : _j.getFirstPosition(), ...(_k = root.getRight()) === null || _k === void 0 ? void 0 : _k.getFirstPosition()])];\n            }\n            else {\n                root.firstPosition = (_m = (_l = root.getLeft()) === null || _l === void 0 ? void 0 : _l.getFirstPosition().map((val) => val)) !== null && _m !== void 0 ? _m : [];\n            }\n            if (rightIsNullable) {\n                root.lastPosition = [...new Set([...(_o = root.getLeft()) === null || _o === void 0 ? void 0 : _o.getLastPosition(), ...(_p = root.getRight()) === null || _p === void 0 ? void 0 : _p.getLastPosition()])];\n            }\n            else {\n                root.lastPosition = (_r = (_q = root.getRight()) === null || _q === void 0 ? void 0 : _q.getLastPosition().map((val) => val)) !== null && _r !== void 0 ? _r : [];\n            }\n        }\n        else if (currentChar === Constants_1.KLEENE) {\n            root.setNullable(true);\n            root.firstPosition = (_t = (_s = root.getLeft()) === null || _s === void 0 ? void 0 : _s.getFirstPosition().map((val) => val)) !== null && _t !== void 0 ? _t : [];\n            root.lastPosition = (_v = (_u = root.getLeft()) === null || _u === void 0 ? void 0 : _u.getLastPosition().map((val) => val)) !== null && _v !== void 0 ? _v : [];\n        }\n        else {\n            root.setTreeNodeId(counter.counter++);\n            alreadyIncremented = true;\n            root.firstPosition.push(root.treeBuilderId);\n            root.lastPosition.push(root.treeBuilderId);\n            isOperator = false;\n        }\n        if (!(alreadyIncremented || isOperator)) {\n            root.setTreeNodeId(counter.counter++);\n        }\n    }\n    static from(regex, counter = { counter: 1 }) {\n        const newTree = TreeNode.generate(regex, counter);\n        if (!newTree)\n            return null;\n        TreeNode.clean(newTree, 'l');\n        TreeNode.setDFAInputs(newTree);\n        return newTree;\n    }\n}\nexports.TreeNode = TreeNode;\nexports[\"default\"] = { TreeNode };\n\n\n//# sourceURL=webpack://proyecto2/./src/Controllers/Tree.ts?")},"./src/Server.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst CCompiler_1 = __webpack_require__(/*! ./Controllers/CCompiler */ \"./src/Controllers/CCompiler.ts\");\nconst node_process_1 = __webpack_require__(/*! node:process */ \"node:process\");\nif (!node_process_1.argv[2])\n    throw new Error('compiler name not provided');\nconst fileName = node_process_1.argv[2];\nconst NAME_FILE_TESTING = `../Testing/${fileName}.atg`;\nconst outputDir = path_1.default.join(__dirname, '..', 'output');\ntry {\n    fs_1.default.mkdirSync(outputDir);\n}\ncatch (_a) {\n}\nconsole.log(`Created directory ${outputDir} for output`);\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        while (yield execute()) {\n        }\n    });\n}\nfunction execute() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Preprocessor\n        // region\n        const input = yield new Promise((resolve, reject) => fs_1.default.readFile(path_1.default.join(__dirname, NAME_FILE_TESTING), { encoding: 'utf-8' }, (err, result) => err ? reject(err) : resolve(result)));\n        // Remove all the line breaks\n        // @ts-ignore\n        const cleaned = input.replaceAll('\\r\\n', '\\n').split('\\n')\n            .filter((val) => !!val)\n            .map(CCompiler_1.CompilerHelper.sanitize);\n        // endregion\n        // Check that all the necessary keywords are in there\n        const deterministicAutomatons = new CCompiler_1.CompilerHelper({ COMPILER: CCompiler_1.COMPILER, CHARACTERS: CCompiler_1.CHARACTERS, END: CCompiler_1.END, KEYWORDS: CCompiler_1.KEYWORDS, TOKENS: CCompiler_1.TOKENS, content: cleaned });\n        const output = deterministicAutomatons.toString();\n        console.log(`Writing ${fileName}_output.txt to ${path_1.default.join(outputDir, `${fileName}_output.txt`)}`);\n        const template = yield new Promise((resolve, reject) => fs_1.default.readFile(path_1.default.join(__dirname, 'template.js'), { encoding: 'utf-8' }, (err, result) => err ? reject(err) : resolve(result)));\n        const reactTemplate = yield new Promise((resolve, reject) => fs_1.default.readFile(path_1.default.join(__dirname, 'template.js'), { encoding: 'utf-8' }, (err, result) => err ? reject(err) : resolve(result)));\n        fs_1.default.writeFileSync(path_1.default.join(outputDir, `dfa_output.json`), output, { encoding: 'utf-8' });\n        fs_1.default.writeFileSync(path_1.default.join(outputDir, `lexer_output.js`), template, { encoding: 'utf-8' });\n        fs_1.default.writeFileSync(path_1.default.join(outputDir, `react_lexer_output.js`), reactTemplate, { encoding: 'utf-8' });\n        // TODO: Add a way to write the deterministic Automaton for the scanner\n        return false;\n    });\n}\nmain();\n\n\n//# sourceURL=webpack://proyecto2/./src/Server.ts?")},"./src/index.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//#region Imports\nconst path_1 = __importDefault(__webpack_require__(/*! path */ "path"));\n//#endregion\n//#region Set ENV Variables\n// Sets the CONFIG directory\nprocess.env.NODE_CONFIG_DIR = path_1.default.join(__dirname, \'..\', \'config\');\n//#endregion\n// Imports the server as to run the actual program\n__webpack_require__(/*! ./Server */ "./src/Server.ts");\n\n\n//# sourceURL=webpack://proyecto2/./src/index.ts?')},fs:e=>{e.exports=require("fs")},"node:process":e=>{e.exports=require("node:process")},path:e=>{e.exports=require("path")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n){if(void 0!==n.error)throw n.error;return n.exports}var t=__webpack_module_cache__[e]={exports:{}};try{var r={id:e,module:t,factory:__webpack_modules__[e],require:__webpack_require__};__webpack_require__.i.forEach((function(e){e(r)})),t=r.module,r.factory.call(t.exports,t,t.exports,r.require)}catch(e){throw t.error=e,e}return t.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.c=__webpack_module_cache__,__webpack_require__.i=[],__webpack_require__.hu=e=>e+"."+__webpack_require__.h()+".hot-update.js",__webpack_require__.hmrF=()=>"server."+__webpack_require__.h()+".hot-update.json",__webpack_require__.h=()=>"7fed9f110346adc64c51",__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),(()=>{var e,n,t,r={},o=__webpack_require__.c,s=[],i=[],a="idle",c=0,l=[];function u(e){a=e;for(var n=[],t=0;t<i.length;t++)n[t]=i[t].call(null,e);return Promise.all(n)}function d(){0==--c&&u("ready").then((function(){if(0===c){var e=l;l=[];for(var n=0;n<e.length;n++)e[n]()}}))}function p(e){if("idle"!==a)throw new Error("check() is only allowed in idle status");return u("check").then(__webpack_require__.hmrM).then((function(t){return t?u("prepare").then((function(){var r=[];return n=[],Promise.all(Object.keys(__webpack_require__.hmrC).reduce((function(e,o){return __webpack_require__.hmrC[o](t.c,t.r,t.m,e,n,r),e}),[])).then((function(){return n=function(){return e?h(e):u("ready").then((function(){return r}))},0===c?n():new Promise((function(e){l.push((function(){e(n())}))}));var n}))})):u(g()?"ready":"idle").then((function(){return null}))}))}function _(e){return"ready"!==a?Promise.resolve().then((function(){throw new Error("apply() is only allowed in ready status (state: "+a+")")})):h(e)}function h(e){e=e||{},g();var r=n.map((function(n){return n(e)}));n=void 0;var o=r.map((function(e){return e.error})).filter(Boolean);if(o.length>0)return u("abort").then((function(){throw o[0]}));var s=u("dispose");r.forEach((function(e){e.dispose&&e.dispose()}));var i,a=u("apply"),c=function(e){i||(i=e)},l=[];return r.forEach((function(e){if(e.apply){var n=e.apply(c);if(n)for(var t=0;t<n.length;t++)l.push(n[t])}})),Promise.all([s,a]).then((function(){return i?u("fail").then((function(){throw i})):t?h(e).then((function(e){return l.forEach((function(n){e.indexOf(n)<0&&e.push(n)})),e})):u("idle").then((function(){return l}))}))}function g(){if(t)return n||(n=[]),Object.keys(__webpack_require__.hmrI).forEach((function(e){t.forEach((function(t){__webpack_require__.hmrI[e](t,n)}))})),t=void 0,!0}__webpack_require__.hmrD=r,__webpack_require__.i.push((function(l){var h,g,f,m,C=l.module,x=function(n,t){var r=o[t];if(!r)return n;var i=function(i){if(r.hot.active){if(o[i]){var a=o[i].parents;-1===a.indexOf(t)&&a.push(t)}else s=[t],e=i;-1===r.children.indexOf(i)&&r.children.push(i)}else console.warn("[HMR] unexpected require("+i+") from disposed module "+t),s=[];return n(i)},l=function(e){return{configurable:!0,enumerable:!0,get:function(){return n[e]},set:function(t){n[e]=t}}};for(var p in n)Object.prototype.hasOwnProperty.call(n,p)&&"e"!==p&&Object.defineProperty(i,p,l(p));return i.e=function(e){return function(e){switch(a){case"ready":u("prepare");case"prepare":return c++,e.then(d,d),e;default:return e}}(n.e(e))},i}(l.require,l.id);C.hot=(h=l.id,g=C,m={_acceptedDependencies:{},_acceptedErrorHandlers:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:f=e!==h,_requireSelf:function(){s=g.parents.slice(),e=f?void 0:h,__webpack_require__(h)},active:!0,accept:function(e,n,t){if(void 0===e)m._selfAccepted=!0;else if("function"==typeof e)m._selfAccepted=e;else if("object"==typeof e&&null!==e)for(var r=0;r<e.length;r++)m._acceptedDependencies[e[r]]=n||function(){},m._acceptedErrorHandlers[e[r]]=t;else m._acceptedDependencies[e]=n||function(){},m._acceptedErrorHandlers[e]=t},decline:function(e){if(void 0===e)m._selfDeclined=!0;else if("object"==typeof e&&null!==e)for(var n=0;n<e.length;n++)m._declinedDependencies[e[n]]=!0;else m._declinedDependencies[e]=!0},dispose:function(e){m._disposeHandlers.push(e)},addDisposeHandler:function(e){m._disposeHandlers.push(e)},removeDisposeHandler:function(e){var n=m._disposeHandlers.indexOf(e);n>=0&&m._disposeHandlers.splice(n,1)},invalidate:function(){switch(this._selfInvalidated=!0,a){case"idle":n=[],Object.keys(__webpack_require__.hmrI).forEach((function(e){__webpack_require__.hmrI[e](h,n)})),u("ready");break;case"ready":Object.keys(__webpack_require__.hmrI).forEach((function(e){__webpack_require__.hmrI[e](h,n)}));break;case"prepare":case"check":case"dispose":case"apply":(t=t||[]).push(h)}},check:p,apply:_,status:function(e){if(!e)return a;i.push(e)},addStatusHandler:function(e){i.push(e)},removeStatusHandler:function(e){var n=i.indexOf(e);n>=0&&i.splice(n,1)},data:r[h]},e=void 0,m),C.parents=s,C.children=[],s=[],l.require=x})),__webpack_require__.hmrC={},__webpack_require__.hmrI={}})(),(()=>{var e,n,t,r,o=__webpack_require__.hmrS_require=__webpack_require__.hmrS_require||{server:1};function s(e,t){var o=require("./"+__webpack_require__.hu(e)),s=o.modules,i=o.runtime;for(var a in s)__webpack_require__.o(s,a)&&(n[a]=s[a],t&&t.push(a));i&&r.push(i)}function i(s){function i(e){for(var n=[e],t={},r=n.map((function(e){return{chain:[e],id:e}}));r.length>0;){var o=r.pop(),s=o.id,i=o.chain,c=__webpack_require__.c[s];if(c&&(!c.hot._selfAccepted||c.hot._selfInvalidated)){if(c.hot._selfDeclined)return{type:"self-declined",chain:i,moduleId:s};if(c.hot._main)return{type:"unaccepted",chain:i,moduleId:s};for(var l=0;l<c.parents.length;l++){var u=c.parents[l],d=__webpack_require__.c[u];if(d){if(d.hot._declinedDependencies[s])return{type:"declined",chain:i.concat([u]),moduleId:s,parentId:u};-1===n.indexOf(u)&&(d.hot._acceptedDependencies[s]?(t[u]||(t[u]=[]),a(t[u],[s])):(delete t[u],n.push(u),r.push({chain:i.concat([u]),id:u})))}}}}return{type:"accepted",moduleId:e,outdatedModules:n,outdatedDependencies:t}}function a(e,n){for(var t=0;t<n.length;t++){var r=n[t];-1===e.indexOf(r)&&e.push(r)}}__webpack_require__.f&&delete __webpack_require__.f.requireHmr,e=void 0;var c={},l=[],u={},d=function(e){console.warn("[HMR] unexpected require("+e.id+") to disposed module")};for(var p in n)if(__webpack_require__.o(n,p)){var _,h=n[p],g=!1,f=!1,m=!1,C="";switch((_=h?i(p):{type:"disposed",moduleId:p}).chain&&(C="\nUpdate propagation: "+_.chain.join(" -> ")),_.type){case"self-declined":s.onDeclined&&s.onDeclined(_),s.ignoreDeclined||(g=new Error("Aborted because of self decline: "+_.moduleId+C));break;case"declined":s.onDeclined&&s.onDeclined(_),s.ignoreDeclined||(g=new Error("Aborted because of declined dependency: "+_.moduleId+" in "+_.parentId+C));break;case"unaccepted":s.onUnaccepted&&s.onUnaccepted(_),s.ignoreUnaccepted||(g=new Error("Aborted because "+p+" is not accepted"+C));break;case"accepted":s.onAccepted&&s.onAccepted(_),f=!0;break;case"disposed":s.onDisposed&&s.onDisposed(_),m=!0;break;default:throw new Error("Unexception type "+_.type)}if(g)return{error:g};if(f)for(p in u[p]=h,a(l,_.outdatedModules),_.outdatedDependencies)__webpack_require__.o(_.outdatedDependencies,p)&&(c[p]||(c[p]=[]),a(c[p],_.outdatedDependencies[p]));m&&(a(l,[_.moduleId]),u[p]=d)}n=void 0;for(var x,w=[],b=0;b<l.length;b++){var E=l[b],A=__webpack_require__.c[E];A&&(A.hot._selfAccepted||A.hot._main)&&u[E]!==d&&!A.hot._selfInvalidated&&w.push({module:E,require:A.hot._requireSelf,errorHandler:A.hot._selfAccepted})}return{dispose:function(){var e;t.forEach((function(e){delete o[e]})),t=void 0;for(var n,r=l.slice();r.length>0;){var s=r.pop(),i=__webpack_require__.c[s];if(i){var a={},u=i.hot._disposeHandlers;for(b=0;b<u.length;b++)u[b].call(null,a);for(__webpack_require__.hmrD[s]=a,i.hot.active=!1,delete __webpack_require__.c[s],delete c[s],b=0;b<i.children.length;b++){var d=__webpack_require__.c[i.children[b]];d&&((e=d.parents.indexOf(s))>=0&&d.parents.splice(e,1))}}}for(var p in c)if(__webpack_require__.o(c,p)&&(i=__webpack_require__.c[p]))for(x=c[p],b=0;b<x.length;b++)n=x[b],(e=i.children.indexOf(n))>=0&&i.children.splice(e,1)},apply:function(e){for(var n in u)__webpack_require__.o(u,n)&&(__webpack_require__.m[n]=u[n]);for(var t=0;t<r.length;t++)r[t](__webpack_require__);for(var o in c)if(__webpack_require__.o(c,o)){var i=__webpack_require__.c[o];if(i){x=c[o];for(var a=[],d=[],p=[],_=0;_<x.length;_++){var h=x[_],g=i.hot._acceptedDependencies[h],f=i.hot._acceptedErrorHandlers[h];if(g){if(-1!==a.indexOf(g))continue;a.push(g),d.push(f),p.push(h)}}for(var m=0;m<a.length;m++)try{a[m].call(null,x)}catch(n){if("function"==typeof d[m])try{d[m](n,{moduleId:o,dependencyId:p[m]})}catch(t){s.onErrored&&s.onErrored({type:"accept-error-handler-errored",moduleId:o,dependencyId:p[m],error:t,originalError:n}),s.ignoreErrored||(e(t),e(n))}else s.onErrored&&s.onErrored({type:"accept-errored",moduleId:o,dependencyId:p[m],error:n}),s.ignoreErrored||e(n)}}}for(var C=0;C<w.length;C++){var b=w[C],E=b.module;try{b.require(E)}catch(n){if("function"==typeof b.errorHandler)try{b.errorHandler(n,{moduleId:E,module:__webpack_require__.c[E]})}catch(t){s.onErrored&&s.onErrored({type:"self-accept-error-handler-errored",moduleId:E,error:t,originalError:n}),s.ignoreErrored||(e(t),e(n))}else s.onErrored&&s.onErrored({type:"self-accept-errored",moduleId:E,error:n}),s.ignoreErrored||e(n)}}return l}}}__webpack_require__.hmrI.require=function(e,o){n||(n={},r=[],t=[],o.push(i)),__webpack_require__.o(n,e)||(n[e]=__webpack_require__.m[e])},__webpack_require__.hmrC.require=function(a,c,l,u,d,p){d.push(i),e={},t=c,n=l.reduce((function(e,n){return e[n]=!1,e}),{}),r=[],a.forEach((function(n){__webpack_require__.o(o,n)&&void 0!==o[n]?(u.push(s(n,p)),e[n]=!0):e[n]=!1})),__webpack_require__.f&&(__webpack_require__.f.requireHmr=function(n,t){e&&__webpack_require__.o(e,n)&&!e[n]&&(t.push(s(n)),e[n]=!0)})},__webpack_require__.hmrM=function(){return Promise.resolve().then((function(){return require("./"+__webpack_require__.hmrF())})).catch((function(e){if("MODULE_NOT_FOUND"!==e.code)throw e}))}})();var __webpack_exports__=__webpack_require__("./src/index.ts")})();